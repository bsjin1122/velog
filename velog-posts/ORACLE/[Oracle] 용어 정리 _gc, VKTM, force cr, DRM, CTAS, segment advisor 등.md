<h1 id="오라클-파라미터-중-_gc">오라클 파라미터 중 _gc</h1>
<ul>
<li>_gc_로 시작하는 파라미터들은 Oracle RAC (Real Application Clusters) 환경에서 Global Cache (글로벌 캐시) 관리와 관련된 숨겨진 파라미터</li>
</ul>
<h3 id="gc-관련-파라미터들"><em>gc</em> 관련 파라미터들</h3>
<p><strong>1. _gc_affinity_time</strong></p>
<ul>
<li>설명: RAC 인스턴스 간 블록을 할당하는 데 걸리는 시간을 제어하는 파라미터.</li>
<li>기능: 블록의 캐시 일관성을 유지하기 위해 데이터를 어느 인스턴스에 할당할지를 결정하는 시간에 영향을 줍니다.</li>
</ul>
<p><strong>2. _gc_defer_time</strong></p>
<ul>
<li>설명: RAC에서 블록 전송을 지연시키는 시간 제어 파라미터.</li>
<li>기능: 블록이 캐시에 남아 있는 동안 다른 인스턴스로 전송을 지연시켜 네트워크 트래픽을 줄이는 데 사용됩니다.</li>
</ul>
<p><strong>3. _gc_read_mostly_locking</strong></p>
<ul>
<li>설명: 읽기 전용 데이터를 처리할 때 락을 얼마나 자주 걸지 제어하는 파라미터.</li>
<li>기능: 데이터가 읽기 전용인 경우 락을 덜 걸게 하여 성능을 최적화할 수 있습니다.</li>
</ul>
<p><strong>4. _gc_latch_time</strong></p>
<ul>
<li>설명: 글로벌 캐시에서 래치를 취득할 때의 대기 시간을 제어하는 파라미터.</li>
<li>기능: 글로벌 캐시를 제어하기 위한 락을 취득하는데 사용되는 시간에 영향을 줍니다.</li>
</ul>
<p><strong>5. _gc_flush_pending</strong></p>
<ul>
<li>설명: 글로벌 캐시에서 플러시 작업을 수행하는 동안의 동작을 제어.</li>
<li>기능: 글로벌 캐시에서 데이터 블록을 플러시하는 데 관련된 작업을 관리하여 성능 최적화에 도움을 줍니다.</li>
</ul>
<p><strong>6. _gc_rollback_lock</strong></p>
<ul>
<li>설명: 롤백 세그먼트와 관련된 글로벌 캐시의 락 동작을 제어.</li>
<li>기능: RAC 환경에서 롤백 세그먼트에 대한 캐시 락을 처리하여 충돌을 최소화합니다.</li>
</ul>
<p><strong>7. _gc_fence_timeout</strong></p>
<ul>
<li>설명: 글로벌 캐시에서 fence 대기 시간을 제어하는 파라미터.</li>
<li>기능: 여러 RAC 인스턴스에서 충돌을 방지하기 위한 일종의 &quot;울타리&quot; 역할을 하는데, 이 대기 시간은 그동안의 트랜잭션을 조정하는 데 도움을 줍니다.</li>
</ul>
<p><strong>8. _gc_block_lost_retry</strong></p>
<ul>
<li>설명: RAC 환경에서 블록이 손실된 경우 재시도하는 시간을 제어하는 파라미터.</li>
<li>기능: 손실된 블록을 재시도하기 위한 대기 시간이나 횟수를 조정하여 데이터 일관성을 유지합니다.</li>
</ul>
<p><strong>주의사항</strong></p>
<ul>
<li>이 파라미터들은 숨겨진 파라미터들로, Oracle에서 직접 제공하거나 공식적으로 문서화된 것이 아닙니다.</li>
<li>따라서 Oracle 지원팀의 지시 없이 이러한 파라미터들을 변경하는 것은 권장되지 않습니다. 잘못된 설정은 시스템 성능 저하를 일으킬 수 있기 때문입니다.</li>
</ul>
<hr />
<h1 id="drm-dynamic-resource-mastering">DRM (Dynamic Resource Mastering)</h1>
<ul>
<li>Oracle Real Application Clusters (RAC)에서 사용되는 기술로, 클러스터 환경에서 데이터베이스 리소스(예: 데이터 블록, 캐시)들에 대한 마스터 노드의 역할을 동적으로 조정하여 시스템 성능을 최적화하는 기능</li>
</ul>
<h3 id="배경">배경</h3>
<ul>
<li><p>Oracle RAC는 여러 인스턴스가 하나의 데이터베이스를 공유하는 환경에서 운영된다. </p>
</li>
<li><p>여러 노드가 동시에 같은 데이터를 액세스하려고 할 때, 데이터 블록의 일관성을 유지하기 위해 특정 노드가 그 블록에 대한 &quot;마스터&quot; 역할을 담당한다. </p>
</li>
<li><p>마스터 노드는 해당 블록에 대한 변경 사항을 관리하고, 다른 노드에서 해당 블록에 접근할 때 일관성을 보장한다.</p>
</li>
</ul>
<h3 id="dynamic-resource-mastering의-동작-원리">Dynamic Resource Mastering의 동작 원리</h3>
<ul>
<li><p>초기에는 특정 노드가 블록에 대한 마스터 역할을 담당하게 되지만, 데이터 접근 패턴에 따라 필요 시 마스터 노드가 다른 노드로 이동하게 됩니다. </p>
</li>
<li><p>이를 Dynamic Resource Mastering이라고 하며, 주로 다음과 같은 상황에서 발생합니다:</p>
</li>
<li><p><code>데이터 접근 패턴 변화</code></p>
<ul>
<li>특정 데이터에 대한 접근이 한 노드에서 집중되면, 해당 데이터 블록의 마스터 노드를 그 노드로 이동시켜 블록을 빠르게 처리합니다.<blockquote>
<ul>
<li>마스터 노드: Oracle RAC (Real Application Clusters) 환경에서 특정 데이터 블록이나 리소스에 대한 변경 및 일관성을 관리하는 역할을 맡는 노드</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>부하 균형: 특정 노드에 부하가 집중되지 않도록 리소스를 동적으로 분배하여 성능을 최적화합니다.</p>
</li>
<li><p>캐시 효율성: 데이터를 자주 참조하는 노드가 마스터 노드가 되면, 데이터 캐시의 일관성을 빠르게 관리할 수 있습니다.</p>
</li>
</ul>
<h3 id="dynamic-resource-mastering의-장점">Dynamic Resource Mastering의 장점</h3>
<ul>
<li><p>성능 향상: 리소스 마스터를 접근이 집중되는 노드로 이동시킴으로써 데이터를 더 빠르게 처리할 수 있습니다.</p>
</li>
<li><p>부하 분산: 특정 노드에 과도한 부하가 걸리지 않도록 리소스를 동적으로 조정하여 전체 시스템 성능을 최적화합니다.</p>
</li>
<li><p>네트워크 병목 감소: 리소스 마스터의 위치를 최적화함으로써, 데이터 블록을 여러 노드로 전달하는 과정을 최소화하여 네트워크 병목 현상을 줄일 수 있습니다.</p>
</li>
</ul>
<h3 id="oracle-rac에서의-활용">Oracle RAC에서의 활용</h3>
<ul>
<li>DRM은 Oracle RAC 환경에서 <strong>Global Cache Service (GCS)</strong>와 <strong>Global Enqueue Service (GES)</strong>를 통해 구현됩니다. </li>
<li>GCS는 데이터 블록을 관리하고, GES는 리소스에 대한 잠금 관리를 담당하며, 이 둘을 통해 리소스 마스터가 동적으로 이동하게 됩니다.</li>
</ul>
<hr />
<h1 id="ctas">CTAS</h1>
<ul>
<li>Create Table As Select의 약자로, 기존 테이블이나 쿼리 결과를 기반으로 새로운 테이블을 생성하는 SQL 문을 말합니다. CTAS는 데이터를 복사하여 새로운 테이블을 생성할 때 많이 사용됩니다.</li>
</ul>
<hr />
<h1 id="segment-advisor">Segment Advisor</h1>
<ul>
<li><p>Segment Advisor는 Oracle 데이터베이스에서 세그먼트의 저장 공간 효율성을 분석하고 조언을 제공하는 도구입니다.</p>
</li>
<li><p>이 도구는 테이블, 인덱스, 파티션 등의 세그먼트에 대해 저장 공간을 얼마나 효율적으로 사용하는지 평가하고, 공간 회수(재사용) 또는 재구성을 제안합니다.</p>
</li>
</ul>
<h2 id="segment-advisor의-주요-기능">Segment Advisor의 주요 기능</h2>
<ul>
<li><p>사용되지 않는 공간 식별</p>
<ul>
<li>테이블이나 인덱스와 같은 세그먼트에서 사용되지 않는 공간을 찾아냅니다. </li>
<li>테이블이나 인덱스에서 삭제된 데이터가 남긴 빈 공간은 성능에 영향을 줄 수 있습니다.</li>
<li>이때, 사전 할당된 빈 공간을 감지하고 불필요한 공간을 제거할지에 대해 조언합니다.</li>
</ul>
</li>
<li><p>재구성 제안</p>
<ul>
<li>세그먼트가 비효율적으로 저장 공간을 사용하는 경우에는 세그먼트의 재구성(Reorganization)을 권장합니다. </li>
<li>이 과정은 데이터를 압축하거나 조정하여 공간을 절약할 수 있습니다.</li>
<li>테이블의 경우, 온라인 테이블 재정렬 또는 인덱스 재구성을 권장할 수 있습니다.</li>
</ul>
</li>
<li><p>공간 압축</p>
<ul>
<li>일부 데이터베이스 객체는 압축을 통해 저장 공간을 줄일 수 있습니다. </li>
<li>Segment Advisor는 데이터가 더 이상 사용되지 않거나 비효율적으로 저장되는 경우, 데이터 압축을 사용하여 공간 절약을 권장할 수 있습니다.</li>
</ul>
</li>
<li><p>파티션의 공간 관리</p>
<ul>
<li>파티션 테이블의 경우, 각 파티션이 얼마나 효율적으로 공간을 사용하고 있는지 평가하고, 불필요한 공간을 회수하는 방법을 권장합니다.</li>
</ul>
</li>
<li><p>자동 공간 분석</p>
<ul>
<li>Oracle Database는 자동 작업으로 Segment Advisor를 실행하여 테이블 및 인덱스의 상태를 모니터링할 수 있습니다. </li>
<li>이 작업은 자동으로 공간 문제를 감지하고 관리자에게 적절한 조언을 제공합니다.</li>
</ul>
</li>
</ul>
<h2 id="segment-advisor-사용-예시">Segment Advisor 사용 예시</h2>
<ul>
<li><p>자주 발생하는 데이터 삭제:</p>
<ul>
<li>특정 테이블에서 대량의 데이터 삭제가 자주 발생하는 경우, 테이블에 남은 빈 공간이 쌓일 수 있습니다. </li>
<li>Segment Advisor는 이를 감지하고, 해당 테이블에 대해 Shrink 작업을 권장할 수 있습니다. 이는 남은 빈 공간을 줄여 저장 공간을 더 효율적으로 사용할 수 있도록 돕습니다.</li>
</ul>
</li>
<li><p>세그먼트 공간 재사용</p>
<ul>
<li>테이블이 공간을 비효율적으로 사용하는 경우, Segment Advisor는 ALTER TABLE ... SHRINK SPACE 명령을 통해 남은 빈 공간을 제거하고, 더 작은 크기의 테이블로 재구성할 수 있는 방안을 제시합니다.</li>
</ul>
</li>
<li><p>인덱스 재구성</p>
<ul>
<li>인덱스가 공간을 비효율적으로 사용할 때, Segment Advisor는 인덱스 재구성을 권장하여 성능 향상 및 공간 최적화를 도울 수 있습니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Segment Advisor는 Oracle Database에서 세그먼트의 저장 공간 사용 상태를 분석하고, 불필요한 공간을 회수하거나 세그먼트를 재구성하는 방법을 제안하는 도구입니다. 
이를 통해 공간 관리 효율성을 높이고, 데이터베이스 성능을 유지하는 데 기여합니다.</p>
</blockquote>
<hr />
<h1 id="vktm">VKTM</h1>
<ul>
<li>VKTM은 Oracle 데이터베이스에서 Virtual Keeper of Time의 약자 <code>시간을 관리하는 백그라운드 프로세스</code>입니다. </li>
<li>이 프로세스는 Oracle 11g부터 도입되었으며, 데이터베이스의 타임 관련 작업을 조정하고 관리하는 역할을 수행합니다.</li>
</ul>
<h3 id="vktm의-주요-역할">VKTM의 주요 역할</h3>
<ul>
<li><p>시간 동기화: VKTM은 Oracle 데이터베이스에서 각종 타이밍 작업(예: 타이머, 시간 대기 이벤트 등)을 정확하게 수행할 수 있도록 시스템 시간과 데이터베이스 시간을 동기화합니다.</p>
</li>
<li><p>정확한 타이머 제공: VKTM은 타이머 기반 작업, 특히 백그라운드 프로세스나 특정 대기 이벤트에서 요구되는 타이밍 정보를 제공합니다. 이로 인해 Oracle 내부의 작업들이 정해진 시간 간격으로 정확하게 실행됩니다.</p>
</li>
<li><p>기본 타임 소스 역할: 데이터베이스 내에서 사용되는 타임스탬프와 같은 시간 관련 정보를 제공하며, Oracle 데이터베이스에서 시간 의존적인 기능들을 원활하게 동작하도록 돕습니다.</p>
</li>
</ul>
<h3 id="vktm이-필요한-이유">VKTM이 필요한 이유</h3>
<ul>
<li>Oracle 데이터베이스에서 여러 프로세스가 동시에 실행되기 때문에, 
이들 프로세스 간의 시간 동기화는 매우 중요합니다. </li>
<li>VKTM은 시스템 시간에 대한 고해상도의 정보를 제공하여 이러한 동기화를 보장하고, 시간 기반 작업을 정확하게 수행할 수 있도록 돕습니다.</li>
</ul>
<blockquote>
<p>VKTM은 Oracle 데이터베이스에서 시간 관련 작업을 관리하는 프로세스로, 백그라운드에서 시간 동기화를 유지하며 정확한 타이밍 정보를 제공하는 역할을 합니다.</p>
</blockquote>
<hr />
<h1 id="force-cr">force cr</h1>
<ul>
<li><p><strong>Force CR (Consistent Read)</strong>는 Oracle 데이터베이스에서 강제 일관성 읽기를 의미</p>
</li>
<li><p>이는 주로 데이터의 일관성을 유지하면서 데이터를 읽어오는 방식 중 하나</p>
</li>
<li><p>Oracle은 데이터 변경이 발생하는 상황에서도 다른 세션에서 일관성 있는 데이터를 읽을 수 있도록, 일관성 읽기(Consistent Read, CR) 메커니즘을 사용합니다.</p>
</li>
</ul>
<h2 id="force-cr의-동작-원리">Force CR의 동작 원리</h2>
<ul>
<li><p>Oracle은 다중 사용자 환경에서 트랜잭션 격리를 위해, 데이터를 읽을 때 변경 중인 데이터를 바로 읽지 않고 Undo Segment(되돌림 세그먼트)에서 해당 데이터의 이전 버전을 참조하여 읽습니다. </p>
</li>
<li><p>이렇게 함으로써, 다른 사용자가 데이터를 변경하더라도 이전의 일관성 있는 데이터 상태를 유지한 채로 읽어올 수 있습니다.</p>
</li>
<li><p>Force CR은 데이터를 읽을 때 이미 변경된 데이터 블록을 읽는 대신, 강제로 해당 블록의 일관된 상태를 복구하여 읽는 메커니즘입니다. 일반적으로 다음과 같은 경우에 발생할 수 있습니다:</p>
</li>
<li><p><code>변경된 데이터 블록을 읽을 때</code>: 다른 트랜잭션이 데이터 블록을 변경했거나 커밋하지 않은 데이터를 포함하고 있을 때, Oracle은 강제로 CR을 실행하여 일관된 데이터를 제공하기 위해 Undo 세그먼트를 사용하여 해당 블록의 이전 버전을 참조합니다.</p>
</li>
<li><p><code>Undo 데이터 사용</code>: Force CR이 발생하면, Undo Segment에 저장된 이전 데이터를 활용하여 데이터를 읽습니다. 이를 통해 트랜잭션의 변경 사항이 완료되지 않은 상태에서도 일관성 있는 데이터를 읽을 수 있게 됩니다.</p>
</li>
</ul>
<h2 id="force-cr이-중요한-이유">Force CR이 중요한 이유</h2>
<ul>
<li><p>데이터 일관성 유지: 여러 사용자가 동시에 데이터베이스에 접근하고 데이터를 변경하는 상황에서도, 일관성 있는 데이터를 보장할 수 있습니다.</p>
</li>
<li><p>읽기 성능: Force CR은 성능 관점에서 어느 정도의 오버헤드를 발생시킬 수 있지만, 데이터 일관성을 유지하기 위해 필수적인 작업입니다. Undo Segment에서 데이터를 참조하는 과정에서 추가 I/O가 발생할 수 있습니다.</p>
</li>
</ul>
<hr />
<h1 id="ilm-information-lifecycle-management-stastics">ILM (Information Lifecycle Management) Stastics</h1>
<ul>
<li>ILM (Information Lifecycle Management) Statistics<ul>
<li>Oracle ILM Statistics는 데이터 수명주기에 따른 데이터를 효율적으로 관리하기 위한 도구입니다. </li>
<li><strong>Information Lifecycle Management (ILM)</strong>은 데이터가 생성되고 사용되다가 최종적으로 보관되거나 삭제될 때까지의 전 과정을 관리하는 개념입니다.</li>
</ul>
</li>
</ul>
<h2 id="주요-개념">주요 개념</h2>
<ul>
<li><p>데이터의 중요성은 시간이 지남에 따라 변동합니다. 생성된 지 얼마 안 된 중요한 데이터는 자주 사용되므로 빠른 접근 속도를 요구하고, 오래된 데이터는 덜 자주 사용되므로 저비용의 저장소에 보관될 수 있습니다.</p>
</li>
<li><p>ILM Statistics는 데이터의 이러한 접근 빈도나 크기 변화를 모니터링하여, 각 데이터 세그먼트가 얼마나 자주 사용되고 얼마나 큰 공간을 차지하는지를 기록하고, 자동으로 데이터를 적절한 저장소로 이동시킬 수 있습니다.</p>
</li>
<li><p>이를 통해, 자주 사용되지 않는 데이터를 덜 비용이 드는 저성능 스토리지로 이동시키거나, 자주 사용되는 데이터를 고성능 스토리지에 유지시키는 등의 데이터 계층화가 가능합니다.</p>
</li>
</ul>
<h2 id="ilm의-주요-기능">ILM의 주요 기능</h2>
<ul>
<li><p><code>자동 데이터 계층화</code>: 데이터가 자주 사용되거나 업데이트되는 시점에서 고성능 스토리지에 유지되도록 하고, 오래된 데이터는 저비용의 스토리지로 자동 이동시킵니다.</p>
</li>
<li><p><code>자동화된 공간 관리</code>: 오래된 데이터의 경우 압축을 통한 공간 절약이나, 적절한 보관 장소로 자동 이동이 가능합니다.</p>
</li>
<li><p><code>접근 빈도 및 변화량 추적</code>: ILM 통계를 사용하여 데이터의 변화를 추적하고, 자주 사용되는 데이터와 사용되지 않는 데이터를 구분하여 관리할 수 있습니다.</p>
</li>
</ul>
