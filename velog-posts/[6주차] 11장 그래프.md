<ul>
<li>출처: <a href="https://www.inflearn.com/course/cpp-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%A9%EA%B2%A9/dashboard">코딩테스트 합격자 되기 C++편 - 11장 그래프</a></li>
</ul>
<blockquote>
<p>목차</p>
</blockquote>
<ul>
<li><a href="https://api.velog.io/rss/@greendev#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EA%B0%9C%EB%85%90">그래프의 개념</a></li>
<li><a href="https://api.velog.io/rss/@greendev#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EC%A2%85%EB%A5%98">그래프의 종류</a></li>
<li><a href="https://api.velog.io/rss/@greendev#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%ED%91%9C%ED%98%84">그래프의 표현(배열/인접리스트)</a><ul>
<li><a href="https://api.velog.io/rss/@greendev#%EC%9D%B8%EC%A0%91-%ED%96%89%EB%A0%AC">배열</a></li>
<li><a href="https://api.velog.io/rss/@greendev#%EC%9D%B8%EC%A0%91-%EB%A6%AC%EC%8A%A4%ED%8A%B8">인접리스트</a></li>
</ul>
</li>
<li><a href="https://api.velog.io/rss/@greendev#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%ED%83%90%EC%83%89">깊이 우선 탐색 / 너비우선 탐색</a></li>
<li><a href="https://api.velog.io/rss/@greendev#%EC%B5%9C%EC%86%8C-%EA%B2%BD%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">최소 경로 알고리즘(다익스트라/ 밸만 포드)</a></li>
</ul>
<h2 id="그래프의-개념">그래프의 개념</h2>
<ul>
<li>노드와 간선을 이용한 비선형 자료구조<ul>
<li>목적에 따라 간선의 가중치나 방향이 있을 수 있음</li>
</ul>
</li>
</ul>
<h2 id="그래프의-종류">그래프의 종류</h2>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/8ad46fe2-0b08-4e21-b64c-ee9b5e85f59b/image.png" /></p>
<ul>
<li>가중치가 있는 그래프</li>
<li>가중치가 없는 그래프</li>
<li>정점이 서로를 가리키는 방향의 간선이 있을 수 있는 그래프</li>
<li>순환이 있는 그래프</li>
<li>순환이 없는 그래프</li>
</ul>
<h2 id="그래프의-표현">그래프의 표현</h2>
<ul>
<li>(배열/인접리스트)<h3 id="인접-행렬">인접 행렬</h3>
</li>
<li>행과 열의 인덱스로 노드의 값을 나타내고, 배열의 값은 간선의 가중치가 된다.</li>
<li>노드 대비 간선이 적을 경우, 메모리 공간 효율이 좋지 않다.
<img alt="" src="https://velog.velcdn.com/images/greendev/post/7a4efd6b-99bb-4fed-b418-9ada9539df38/image.png" /></li>
<li>구현은 쉽지만, 그래프에 따라 메모리를 낭비할 수 있다.</li>
<li>장점: 특정 노드 사이 간선 존재 여부를 한 번에 알 수 있다.</li>
<li>ex) 0-&gt;4 graph[0][4]로 한 번에 확인 가능</li>
</ul>
<h3 id="인접-리스트">인접 리스트</h3>
<ul>
<li>특정 시작 노드를 연결된 노드들을 리스트로 연결하는 방식</li>
<li>실제 그래프의 노드 갯수만큼만 추가하므로, 메모리 낭비 없음</li>
<li>특정 노드에 모든 노드가 연결된 경우, 탐색 시 O(N)이 될 수 있음(드문 케이스)</li>
</ul>
<h4 id="표현-방식">표현 방식</h4>
<ol>
<li>노드 개수만큼 배열을 준비한다. (각 배열 인덱스는 시작 노드를 의미)</li>
</ol>
<ul>
<li><img alt="" src="https://velog.velcdn.com/images/greendev/post/0105f93d-e6b5-44be-a0ee-278e160c3335/image.png" /></li>
</ul>
<ol start="2">
<li>각 배열의 인덱스는 시작 노드를 나타낸다. 해당 인덱스에 연결된 노드를 추가한다.</li>
</ol>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/c12d87ea-1776-4ce7-b70e-959ebf9d7e29/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/84033d2d-38aa-4dcf-b9b8-210699c87011/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/ea3a3d84-df15-47bf-8d81-b8a53bc3c09e/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/0d8d4663-7e3a-41f6-aa1c-d26d9ce27b71/image.png" /></p>
<h3 id="인접-행렬-vs-인접-리스트">인접 행렬 vs 인접 리스트</h3>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/22857f89-fc01-4c45-9654-21878bff3dec/image.png" /></p>
<h2 id="그래프의-탐색">그래프의 탐색</h2>
<h3 id="깊이-우선-탐색dfs">깊이 우선 탐색(DFS)</h3>
<ul>
<li>더 이상 탐색할 노드가 없을 때까지 일단 간다.</li>
<li>더 이상 탐색할 노드가 없으면, 최근에 방문했던 퇴각(백트래킹) 후, 가지 않은 노드 방문
<img alt="" src="https://velog.velcdn.com/images/greendev/post/8f1928fa-6aa2-4ec0-9a46-c7f1b07eead3/image.png" />
<img alt="" src="https://velog.velcdn.com/images/greendev/post/074eb41f-53a8-490e-b8c2-909b85a63316/image.png" />
<img alt="" src="https://velog.velcdn.com/images/greendev/post/7b88c83c-6b31-46ab-bbad-e63178204a6b/image.png" />
<img alt="" src="https://velog.velcdn.com/images/greendev/post/66b6b468-1c64-41ab-b767-080b55694184/image.png" /><h3 id="어떻게-구현할-것인가">어떻게 구현할 것인가?</h3>
</li>
</ul>
<ol>
<li>계속해서 깊이 탐색할 수 있어야 함</li>
<li>더 이상 깊은 곳이 없는 경우, 가장 최근에 방문했던 노드로 퇴각해야 함</li>
<li>이미 방문한 노드는 중복해서 방문하지 않아야 함</li>
</ol>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/4e0ed827-2af2-46b1-8a4e-31da2414a5dc/image.png" /></p>
<ul>
<li>stack 자료구조와 동일한 흐름을 갖고 있다.</li>
<li>함수의 call stack도 stack과 같이 동작하므로, 재귀함수로 구현하는 경우가 많다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/ce854e98-cffd-48a1-8cd4-afab58eec426/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/c1864058-9372-42b0-bd9e-4933a5e48888/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/5ee58e85-f235-486c-a59f-5c53b28b9a7f/image.png" /></p>
<h3 id="너비-우선-탐색bfs">너비 우선 탐색(BFS)</h3>
<ul>
<li>현재 위치에서 가장 가까운 노드부터 방문하고 다음 노드로 넘어감</li>
<li>모든 노드를 방문할 때까지 위 과정 반복</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/06f45b73-c8af-4f64-80fa-5a29876aae70/image.png" /></p>
<ul>
<li>가깝다는 기준: 간선 몇 개를 거치느냐 
<img alt="" src="https://velog.velcdn.com/images/greendev/post/f21a8897-beeb-438b-afe2-47529a5887fd/image.png" />
<img alt="" src="https://velog.velcdn.com/images/greendev/post/2c850fa1-daa3-4e45-8b17-542a6a009c0b/image.png" /><h3 id="어떻게-구현할까">어떻게 구현할까?</h3>
</li>
</ul>
<ol>
<li>루트 노드부터 시작해서, 가장 가까운 노드들부터 방문할 수 있어야 한다.</li>
</ol>
<ul>
<li>루트 노드 방문 -&gt; 1개 간선으로 갈 수 있는 노드 방문 -&gt; 2개 간선으로 갈 수 있는 노드 방문... (모든 노드를 방문할 때까지 반복)</li>
<li>큐를 사용해서 넣음 - 시작 노드를 pop하면서, b,c를 방문해서 넣음 </li>
<li>b를 pop 하면서, 아직 방문하지 않은 노드 d, e를 push</li>
<li>c를 pop 하면서, 방문하지 않는 노드들이 없기 때문에 그냥 빠짐</li>
<li>d 도 pop, e도 pop</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/75f23721-6103-4c0c-a3e6-7cd6e6f9cf66/image.png" /></p>
<h2 id="정리">정리</h2>
<ul>
<li>백트래킹은 깊이 우선 탐색에만 존재<ul>
<li>스도쿠 문제, 1~5를 사용해서 합이 10이 되는 모든 경우</li>
</ul>
</li>
<li>너비 우선 탐색으로 찾은 최적해를 보장<ul>
<li><img alt="" src="https://velog.velcdn.com/images/greendev/post/3be841a3-b9f0-440d-a3e2-1059c2c838c7/image.png" /></li>
<li>깊이 우선은 시작 노드에서 가장 가까운 해라는 것 보장이 안된다.</li>
<li>시작점에서 끝지점까지 가는데 최소 스텝수</li>
</ul>
</li>
<li>너비우선탐색은 모든 다음 노드를 큐에 푸시하므로, 깊이 우선탐색보다 메모리 사용량이 높다.</li>
<li>물론 둘다 되는 경우가 존재, 애매하면 깊이 우선 탐색 먼저 시도</li>
</ul>
<h2 id="최소-경로-알고리즘">최소 경로 알고리즘</h2>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/542eb443-53ee-479e-b09e-cae4bb40bd3a/image.png" /></p>
<ul>
<li>두 노드를 잇는 가중치의 합을 최소로 하는 경로를 찾는 알고리즘</li>
<li>아래 경우, 1-&gt;2-&gt;5는 가중치가 24이므로 최단 경로가 된다.</li>
<li>1-&gt;5는 가중치가 49임: 간선의 개수가 1개로 가장 적어 최단 경로가 되지만</li>
<li>가중치의 합을 기준으로 하면, 1-&gt;5는 가중치가 39이고, 1-&gt;2-&gt;5는 가중치가 24이므로 이것이 최단 경로가 된다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/9124461b-e8b2-4490-854c-5e8fb1645d01/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/4038fa2e-8f24-43dc-8e8f-9b262216d9de/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/878679e6-59bd-431e-9fb0-0b8f3ac0bfbc/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/ac779362-3fba-4857-af24-f65a25887dcb/image.png" /></p>
<ul>
<li>직전노드: 최소 비용으로, 시작 노드에서 도착 노드까지 갈 때 경로를 구해주는 것(자기 자신, 나머지는 INF무한대)</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/4d332a90-09d4-4fcd-ada1-067d1c612208/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/552452ae-0742-4eda-8872-9aaaaba91cd4/image.png" /></p>
<ul>
<li>나머지 간선의 가중치가 가장 적은 게 E 면 , 후보노드가 된다. </li>
<li>visited=[A, E]</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/5da640f6-953a-468f-82c2-b0c91eadd7bd/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/7bea7c21-2ccb-43b3-ba92-7f8db684ecfc/image.png" /></p>
<ul>
<li>B와 D 중 최소 비용이 더 작은 것을 후보노드로 추가</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/cb4eb3ef-a500-4cc8-8c0e-366170daa16b/image.png" /></p>
<ul>
<li>4+6 &lt; 3 -&gt; <code>갱신 안 됨</code></li>
<li>후보 노드는 D 하나 남음</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/5ade6ba0-432e-4674-b436-b10608af490a/image.png" /></p>
<ul>
<li>11 + 5 &lt; 0 -&gt; <code>갱신 안 됨</code></li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/f9cfbd65-679e-4395-9d19-31b884ad90c2/image.png" /></p>
<ul>
<li>A -&gt; E -&gt; C 최소 비용은 1+2=3</li>
<li>자신의 직전 노드만 봐도, 최소 비용을 알 수 있다.
<img alt="" src="https://velog.velcdn.com/images/greendev/post/bf5915ca-6439-4dae-a37b-ed818ed670a0/image.png" /></li>
<li>A-&gt; E -&gt; C -&gt; D : 11</li>
</ul>
<h2 id="다익스트라-알고리즘의-구현">다익스트라 알고리즘의 구현</h2>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/a34da8a0-786e-4385-89c3-9a80c4f56638/image.png" /></p>
<ul>
<li>현재까지 후보가 되지 않았던 노드 중, 최소 비용이 가장 적은 노드</li>
<li>visited 배열을 활용해 방문 여부를 체크 </li>
</ul>
<h2 id="음의-가중치가-있는-그래프에서-다익스트라-알고리즘은">음의 가중치가 있는 그래프에서 다익스트라 알고리즘은?</h2>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/33af5a4d-6914-49a6-a458-b5a82ef94c77/image.png" /></p>
<ul>
<li>후보노드: 현재까지 구한 최소 비용 중에, 가장 최소비용이 적은 노드</li>
<li>다익스트라 알고리즘이 최소 비용을 계속 갱신, 후보노드의 최소비용은 갱신이 안 될 것이라고 가정했었음</li>
<li>잘 동작할 수도, 잘 동작하지 않을 수 있다.</li>
<li>음의 가중치 있을 경우, 밸만-포드 알고리즘을 사용해야 한다. (책 참조)</li>
</ul>