<p>출처: <a href="https://www.inflearn.com/course/cpp-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%A9%EA%B2%A9/dashboard">코딩 테스트 합격자 되기 C++편</a></p>
<blockquote>
<h2 id="목차">목차</h2>
</blockquote>
<ul>
<li>상호배타적 집합이란? </li>
<li>집합의 연산<ul>
<li>union 연산과 find 연산</li>
<li>경로 압축/ 랭크 기반 알고리즘으로 계산하기</li>
</ul>
</li>
<li>집합의 구현</li>
</ul>
<hr />
<h1 id="상호배타적-집합">상호배타적 집합</h1>
<ul>
<li>교집합이 없는 집합 관계</li>
<li>집합은 꼭 2개가 아니라, N개일 수도 있다.
<img alt="" src="https://velog.velcdn.com/images/greendev/post/a73d96f0-43a5-458a-8c77-2a79186df20b/image.png" /></li>
<li>각 집합의 대표 원소를 만들면 해결이 된다. 👉 루트노드</li>
<li>특정 원소가 어느 집합에 속하는지 알 수 있어야 하며, 두개의 집합을 하나로 합칠 수 있어야 한다. </li>
</ul>
<h1 id="집합-표현하기">집합 표현하기</h1>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/ae0aa860-cc8d-4c3a-9a97-f7f220e14554/image.png" /></p>
<ul>
<li>따라 가다 보면, <code>현재노드 == 부모노드</code> 특정 집합의 대표 원소, 루트 노드가 되는 것을 배열로 표현할 수 있게 된다!</li>
<li>배열 7번째에는 없으면 -1</li>
</ul>
<h1 id="집합의-연산">집합의 연산</h1>
<ul>
<li>find(7) = 1 </li>
<li>특정 노드의 루트 노드를 확인하는 연산</li>
<li>값이 같지 않으면, 부모노드에 find를 함.</li>
<li>union 연산에서도 활용된다. </li>
</ul>
<h2 id="집합의-연산---find-최악의-경우">집합의 연산 - find 최악의 경우</h2>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/eaf7f4e3-60a3-48c9-844d-93332af84854/image.png" /></p>
<ul>
<li>N이 1천만 개일 경우?</li>
<li>경로 압축 알고리즘을 활용하자!
<img alt="" src="https://velog.velcdn.com/images/greendev/post/ad738b64-f7ff-40ce-b794-3591dc3dcedb/image.png" /></li>
<li>경로 압축 알고리즘을 사용하면, O(1)까지도 갈 수 있다.</li>
</ul>
<h1 id="집합의-연산-union">집합의 연산 (union)</h1>
<ul>
<li>두 개의 집합을 하나의 집합으로 합치는 연산</li>
<li>find 연산을 통해 각 집합의 대표 원소를 구하고, 루트 노드를 하나로 통일한다.</li>
<li>union(6,8) -&gt; find(6), find(8)</li>
<li>union 연산을 할 때도, 경로 압축이 될 것이다. 
<img alt="" src="https://velog.velcdn.com/images/greendev/post/5ae2bc9e-d86d-4c8d-9c50-e47fce841c8f/image.png" /></li>
</ul>
<h2 id="집합의-연산union-효율성의-고민">집합의 연산(union, 효율성의 고민)</h2>
<ul>
<li>깊이를 최소화할 수 있을까? </li>
<li>집합에 랭크를 도입하자. (특정 노드 기준 최대 깊이)</li>
<li>랭크가 더 큰 쪽으로 합쳐져, 랭크의 증가를 최소화하자</li>
</ul>
<h2 id="집합의-연산union-랭크기반-알고리즘">집합의 연산(union, 랭크기반 알고리즘)</h2>
<p><img alt="" src="https://velog.velcdn.com/images/greendev/post/569a7b9b-025d-4f75-b5a9-ef581651e33e/image.png" /></p>
<ul>
<li>랭크를 기반으로, 랭크를 낮게 유지하는 방향으로 합치자. </li>
<li>어떻게 합칠까? <ul>
<li>랭크가 더 높은 쪽으로 합친다.</li>
</ul>
</li>
</ul>
<h2 id="집합의-구현">집합의 구현</h2>
<ul>
<li>노드의 최대 값이 크지 않은 경우 -&gt; 배열로 구현</li>
<li>노드의 최대 값이 큰 경우, unordered_map으로 구현</li>
<li>대부분의 코테 문제는 경로 압축, 랭크기반까지 구현할 필요는 없습니다.</li>
</ul>
<h2 id="언제-집합-알고리즘을-사용할까">언제 집합 알고리즘을 사용할까?</h2>
<ul>
<li>이미지 세그멘테이션</li>
<li>각 이미지를 의미있는 부분으로 분할</li>
<li>아래 이미지를 보면, 이미지에서 각 객체마다 분할해서 다른 색을 칠하고 있다.</li>
<li>네트워크 연결성 확인</li>
<li>대규모 네트워크에서 두 컴퓨터가 서로 연결되어 있는지 확인</li>
</ul>